@page "/tasktimer"
@using System.Threading.Tasks
@rendermode InteractiveServer
@implements IAsyncDisposable
@inject IJSRuntime JS

<PageTitle>Task Timer</PageTitle>

<h3>Task Timer</h3>

<div class="card" style="width: 400px;">
    <div class="card-body">
        <h3 class="card-title">Pomodoro Timer</h3>

        <div class="mb-3">
            <p>Remaining Time:&nbsp
                <span id='timerDisplay'>@FormatTime(_taskTimer.RemainingTime)</span>
            </p>
            <p>Current Phase: @CurrentPhase</p>
            <p>Status: @TimerStatus</p>
        </div>

        <button @onclick="TimerLoop" id="startTimerBtn" class="btn btn-primary me-2">
            Start
        </button>

        <button @onclick="TogglePause" id="togglePauseBtn" class="btn btn-warning">
            @(_taskTimer.IsRunning ? "Pause" : "Resume")
        </button>
    </div>
</div>

@code {
    private const int DefaultWorkMinutes = 25;
    private const int DefaultBreakMinutes = 5;

    private Eddy.TaskTimer _taskTimer = new Eddy.TaskTimer(DefaultWorkMinutes, DefaultBreakMinutes);
    private static double CurrentRemainingTimeSecs { get; set; } = DefaultWorkMinutes * 60;
    private string TimerStatus { get; set; } = "Idle";
    private string CurrentPhase { get; set; } = string.Empty;
    private IJSObjectReference? module;

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JS.InvokeAsync<IJSObjectReference>("import", "./Components/Pages/TaskTimer.razor.js");
            await AddHandlers();
        }
    }

    public async Task AddHandlers()
    {
        if (module is not null)
        {
            await module.InvokeVoidAsync("addHandlers", _taskTimer.WorkMinutes);
            StateHasChanged();
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            try
            {
                await module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }

    private async Task StartTimerLoop(CancellationToken cancellationToken) {
        void onTimerCompleted(object? sender, EventArgs eventArgs) {
            CurrentRemainingTimeSecs = _taskTimer.RemainingTime;
            TimerStatus = "Complete";
            InvokeAsync(StateHasChanged).ConfigureAwait(false);
        }
        _taskTimer.TimerCompleted += onTimerCompleted;

        if (cancellationToken.IsCancellationRequested) {
            await _taskTimer.CancelAsync();
        }

        // run until cancellation requested
        while (!cancellationToken.IsCancellationRequested) {
            try {
                await TimerLoop();
            } catch (OperationCanceledException) {
                CurrentRemainingTimeSecs = _taskTimer.RemainingTime;
            }
        }
    }

    private async Task TimerLoop()
    {
        // only start timer if not currently running / stopped
        if (!_taskTimer.IsRunning)
        {
            CurrentRemainingTimeSecs = _taskTimer.RemainingTime;
            await _taskTimer.StartAsync().ConfigureAwait(false);

            // current remaining time may be greater than 0 when timer is cancelled or paused
            CurrentRemainingTimeSecs = _taskTimer.RemainingTime;
        }

        // update
        CurrentPhase = _taskTimer.IsWorkTime ? "Work" : "Break";
        TimerStatus = $"Started {CurrentPhase} timer.";
        await InvokeAsync(StateHasChanged).ConfigureAwait(false);
    }

    private void TogglePause()
    {
        _taskTimer.TogglePause();
        TimerStatus = _taskTimer.IsRunning ? "Resumed" : "Paused";
        CurrentPhase = _taskTimer.IsWorkTime ? $"work ({TimerStatus})" : $"break ({TimerStatus})";
    }

    private string FormatTime(double seconds)
    {
        int minutes = (int)(seconds / 60);
        int remainingSeconds = (int)seconds % 60;

        return $"{minutes:D2}:{remainingSeconds:D2}";
    }
}