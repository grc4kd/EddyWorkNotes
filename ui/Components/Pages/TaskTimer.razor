@page "/tasktimer"
@using Eddy.Requests
@using Markdig
@using ui.Components.Models
@using ui.Data
@rendermode InteractiveServer
@implements IDisposable
@implements IAsyncDisposable

@inject IJSRuntime JS
@inject NotifierService Notifier
@inject ILogger<TaskTimer> Logger
@inject MarkdownPipelineBuilder MarkdownPipelineBuilder
@inject EddyWorkNotesContext EddyWorkNotesContext
@inject TaskTimerService Timer
@inject TimerCycleService TimerCycle

<PageTitle>Task Timer</PageTitle>

<h3>Task Timer</h3>

<div class="card container-md">
    <div class="card-body container-sm">
        <h3 class="card-title">Active Timer</h3>
        <div class="mb-2">
            <div class="mb-2" asp-for="timeRemaining">
                Time Remaining
                <div id="timerDisplay" class="mb-3">@(TimeRemaining.ToString(@"mm\:ss")) remaining</div>
            </div>
        </div>
        <p>Current Phase: @(TimerCycle.CycleName)</p>
        <p>Status: @(CurrentState)</p>
        <p>Current Cycle: @(TimerCycle.CycleCount)</p>
        <button @onclick="StartTimer" class="btn btn-primary" disabled="@StartDisabled">Start</button>
        <button @onclick="SkipTimer" class="btn btn-secondary" disabled="@SkipDisabled">Skip</button>
    </div>

    <div class="card-body container-sm">
        <div class="container-sm">
            <EditForm Model="Model" OnValidSubmit="Submit" FormName="WorkNotes">
                <DataAnnotationsValidator/>
                <ValidationSummary/>

                <div class="row">
                    <label>
                        @if (Timer.IsRunning)
                        {
                            <h2>@TimerCycle.CycleName</h2>
                            <p>Duration: @TimerCycle.CycleTime</p>
                        }
                        else
                        {
                            <p><u>timer is not running</u></p>
                        }
                        <div class="row">
                            <InputTextArea @bind-Value="Model!.Description"/>
                        </div>
                    </label>
                    <div class="pt-4">
                        <button type="submit" class="btn btn-primary">Save</button>
                    </div>
                </div>
            </EditForm>
        </div>
        <div class="card-body container-sm">
            <h3 class="mb-3">History</h3>
            @if (_sessions.Any())
            {
                <div class="d-flex flex-column">
                    @foreach (var session in _sessions)
                    {
                        <div class="card my-2">
                            <div class="card-body">
                                @if (@session.WorkNotes?.Length > 0)
                                {
                                    <p class="card-text"><small class="text-muted">Recorded at
                                            @session.CompletedAtLocaltime.ToShortTimeString()</small></p>
                                    <p class="my-2">@((MarkupString)ParseNotes(session.WorkNotes))</p>
                                }
                            </div>
                        </div>
                    }
                </div>
            }
            else
            {
                <p>No cycles completed yet.</p>
            }
        </div>
    </div>
</div>

<!-- this toast is hidden by default, and controlled by CSS classes 'show' and 'hide' -->
<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
    <div id="toastNotification" class="toast @(_showToast ? "show" : "hide")" role="alert" aria-live="assertive"
         aria-atomic="true">
        <div class="toast-header">
            <strong class="me-auto">Task Timer</strong>
            <small>Cycle complete: @LastCycleCompletedAt</small>
            <button type="button" class="btn-close" data-bs-dismiss="toast" @onclick="() => _showToast = false"
                    aria-label="Close"></button>
        </div>
        <div class="toast-body">
            On a short break for <em>@(_options.BreakTimeSpan.TotalMinutes)</em> minutes. Be right back!
        </div>
    </div>
</div>

@code {

    /// <summary>
    /// Target number of work cycles to loop through. 4 for standard Pomodoro technique.
    /// </summary>
    private const int TargetWorkCycles = 4;

    // DTOs and model class reference types
    private TimeSpan TimeRemaining => Timer.TimeRemaining;
    private readonly TaskTimerOptions _options = new();
    private IJSObjectReference? _module;
    private TaskTimerState CurrentState => Timer.IsRunning ? TaskTimerState.Running : TaskTimerState.Stopped;
    private List<TimerSession> _sessions = [];
    private const int LoopCount = 2 * TargetWorkCycles - 1;

    private string LastCycleCompletedAt
    {
        get
        {
            if (_sessions.Any())
                return _sessions.OrderByDescending(k => k.CompletedAtUtc)
                    .First().CompletedAtLocaltime.ToLongTimeString();
            return "(no time recorded)";
        }
    }

    private bool _showToast;

    // EditForm variables
    [SupplyParameterFromForm] private IWorkNote? Model { get; set; }

    private MarkdownPipeline? MarkdownPipeline { get; set; }

    protected override void OnInitialized()
    {
        Model ??= new WorkNote();

        Timer.Reset();
        TimerCycle.Reset();

        MarkdownPipeline ??= MarkdownPipelineBuilder
            .UseDefinitionLists()
            .UseEmphasisExtras()
            .UseGridTables()
            .UseMathematics()
            .UseMediaLinks()
            .UsePipeTables()
            .UseListExtras()
            .UseTaskLists()
            .UseGenericAttributes()
            .Build();

        // attach an event handler for notifications from the timer service
        Notifier.Notify += OnNotify;

        LoadSessions();
    }

    private async Task OnNotify(string key, int value)
    {
        switch (key)
        {
            case "timerStarted":
                _module?.InvokeVoidAsync("run", value);
                break;
            case "elapsedCount":
                _module?.InvokeVoidAsync("pause");
                break;
            case "timerReset":
                _module?.InvokeVoidAsync("reset");
                break;
        }

        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // ensure to only setup JS interop on first render
        if (firstRender && _module is null)
        {
            _module = await JS.InvokeAsync<IJSObjectReference>("import", "./Components/Pages/TaskTimer.razor.js");
        }

        if (firstRender && !Timer.IsRunning)
        {
            _module?.InvokeVoidAsync("reset");
        }

        if (firstRender && Timer.IsRunning)
        {
            _module?.InvokeVoidAsync("run", Timer.TimeRemaining);
        }
    }

    private void LoadSessions()
    {
        // only load the sessions on the first page load 
        if (_sessions.Any()) return;

        const int lookbackHours = 16;
        _sessions = EddyWorkNotesContext.WorkNote
            .Where(w => w.RecordedAtTimeUtc.ToLocalTime() > DateTime.Now.AddHours(-lookbackHours))
            .Select(w => new TimerSession(w))
            .ToList();
    }

    public void Dispose()
    {
        Notifier.Notify -= OnNotify;
    }

    public async ValueTask DisposeAsync()
    {
        if (_module is not null)
        {
            try
            {
                await _module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Handle exceptions if client JS module is disconnected
                Logger.LogWarning("JavaScript module disconnected with time remaining: {TimeRemaining} minutes",
                    Timer.TimeRemaining.TotalMinutes);
            }
        }
    }

    private bool StartDisabled
    {
        get
        {
            var isCycleCountOverLimit = TimerCycle.CycleCount < 2 * TargetWorkCycles - 1;
            return Timer.IsRunning && !isCycleCountOverLimit;
        }
    }

    private bool SkipDisabled => !Timer.IsRunning;

    /// <summary>
    /// Process form submission and update completed work notes. Do not submit empty notes or duplicate notes.
    /// Trim notes before comparison, but submit all data previously validated in the EditForm.
    /// </summary>
    private void Submit()
    {
        var isInputBlank = (Model == null || string.IsNullOrWhiteSpace(Model?.Description));

        var trimmedNotes = Model?.Description is not null ? TrimNotes(Model) : string.Empty;

        if (Model == null || isInputBlank || _sessions.Any(s => s.WorkNotes?.Trim() == trimmedNotes)) return;
        Logger.LogInformation("Work notes submitted.\n{parsedNotes}", trimmedNotes);

        var session = new TimerSession("Work", DateTime.UtcNow, trimmedNotes);
        var workNote = new DataEntities.WorkNote(trimmedNotes);

        EddyWorkNotesContext.WorkNote.Add(workNote);
        EddyWorkNotesContext.SaveChanges();

        // add notes to current session without reloading the page on inserting the last note
        _sessions = _sessions.Prepend(session).ToList();

        // clear the active notes once completed session notes are stored
        Model!.Description = "";
        return;

        static string TrimNotes(IWorkNote notes) => !string.IsNullOrWhiteSpace(notes.Description) ? notes.Description.Trim() : string.Empty;
    }

    string ParseNotes(string markdown) => Markdown.ToHtml(markdown, MarkdownPipeline);

    private async Task StartTimer()
    {
        // skip the last break timer cycle (run until loopCount-1)
        while (TimerCycle.CycleCount < LoopCount)
        {
            await Timer.Wait(new TaskTimerRequest(TimerCycle.CycleTime));
        }
    }

    private void SkipTimer()
    {
        @* module?.InvokeVoidAsync("pause"); *@

        TimerCycle.Next();
        Timer.Skip();
        StateHasChanged();
    }

}
